//! Path parser
use alloc::string::String;
use alloc::vec::Vec;

const MAX_FILE_NAME_LENGTH: usize = 255;

/// State of path parse
pub enum STATE {
        Start,
        FName,
        DirCur,
        DirParent,
}

/// Errors generated by path parser
#[derive(Clone, Copy)]
pub enum PathFormatError {
        NotAbs,
        NotRel,
        EmptyFileName,
        FileNameTooLong,
        InvalidCharInFileName,
        InvalidCharInFileExt,
        EmptyPath,
        ReferingRootParent,
        Unknown,
}

/// Convert path parser error to text message
pub fn to_string(error: PathFormatError) -> &'static str {
        match error {
                PathFormatError::NotAbs => "Path should start with '/'",
                PathFormatError::NotRel => "Processing non-relative path with relative parser",
                PathFormatError::EmptyFileName => "File name is empty",
                PathFormatError::FileNameTooLong => "File name longer than 255 bytes is not allowed",
                PathFormatError::InvalidCharInFileName => "Invalid char is found in file name",
                PathFormatError::InvalidCharInFileExt => "Invalid char is found in file extension",
                PathFormatError::EmptyPath => "Path is empty",
                PathFormatError::ReferingRootParent => "Path invalid because is refering parent of root",
                PathFormatError::Unknown => "unknown error",
                // _ => "unknown error",
        }
}

/// Path struct
#[derive(Clone)]
pub struct Path {
        /// path chain
        pub path: Vec::<String>,
        /// if the path indicating a directory, it may be a directory when false 
        pub must_dir: bool,
        /// if the path start from root
        pub is_abs: bool,
}

impl Path {
        /// Create a new path struct
        fn new() -> Path {
                return Path {
                        path: Vec::<String>::new(),
                        must_dir: false,
                        is_abs: true,
                };
        }

        /// Handle .. in path
        /// # Description
        /// remove .. and the directory right in front of it when possible 
        pub fn purge(&mut self) -> Result<(), PathFormatError> {
                let mut idx = 0;
                while idx < self.path.len() {
                        if self.path[idx].eq("..") {
                                if idx == 0 && self.is_abs {
                                        return Err(PathFormatError::ReferingRootParent);
                                } else {
                                        self.path.remove(idx);
                                        self.path.remove(idx -1);
                                        idx -= 1;
                                }
                        } else {
                                idx += 1;
                        }
                }
                return Ok(());
        }

        /// Output path in String format
        pub fn to_string(&self) -> String {
                let mut res = String::new();
                if !self.is_abs {
                        res.push('.');
                }
                for part in self.path.iter() {
                        res.push('/');
                        res.push_str(part.as_str());
                }
                res
        }

        /// Pop the last node of the path as a path struct
        pub fn pop(&mut self) -> Option<Path> {
                if self.path.len() != 0 {
                        let vt = vec![self.path.pop().unwrap()];
                        let p = Path {
                                path: vt,
                                must_dir: self.must_dir,
                                is_abs: false,
                        };
                        self.must_dir = true;
                        return Some(p);
                } else {
                        return None;
                }
        }
}

/// Path parser, parser a path from string to Path struct, some checks are included as well
struct PathParser {
        /// State of path parser, parser is implemented as state machine
        state: STATE,
        /// Buffer for temporary use
        buf: String,
        /// Holds intermediate result
        path: Path,
        /// Result
        result: Option<Result<Path, PathFormatError>>,
}

/// Check whether the given char is a valid char of filename
/// # Description
/// Not implemented yet
fn valid_fname_char(_c: char) -> bool {
        return true;
}

impl PathParser {
        /// Create parser
        fn new() -> PathParser {
                return PathParser {
                        state: STATE::Start,
                        buf: String::with_capacity(MAX_FILE_NAME_LENGTH),
                        path: Path::new(),
                        result: None,
                };
        }

        /// Feed parser a char
        fn read(&mut self, c: char) -> Option<Result<Path, PathFormatError>> {
                if let Some(result) = self.result.as_ref() {
                        return Some(result.clone());
                }
                match self.state {
                        STATE::Start => {
                                if c == '/' {
                                        self.state = STATE::FName;
                                        return None;
                                } else {
                                        self.path.is_abs = false;
                                        if c == '.' {
                                                self.buf.push('.');
                                                self.state = STATE::DirCur;
                                                return None;
                                        } else {
                                                if valid_fname_char(c) {
                                                        if self.buf.len() < 255 {
                                                                self.buf.push(c);
                                                                self.state = STATE::FName;
                                                                return None;
                                                        } else {
                                                                self.result = Some(Err(PathFormatError::FileNameTooLong));
                                                                return Some(Err(PathFormatError::FileNameTooLong));
                                                        }
                                                } else {
                                                        self.result = Some(Err(PathFormatError::InvalidCharInFileName));
                                                        return Some(Err(PathFormatError::InvalidCharInFileName));
                                                }
                                        }
                                }
                        },
                        STATE::FName => {
                                if c == '/' {
                                        if self.buf.len() > 0 {
                                                self.path.path.push(self.buf.clone());
                                                self.buf = String::with_capacity(MAX_FILE_NAME_LENGTH);
                                                return None;
                                        } else {
                                                self.result = Some(Err(PathFormatError::EmptyFileName));
                                                return Some(Err(PathFormatError::EmptyFileName));
                                        }
                                } else if c == '.' && self.buf.len() == 0 {
                                        self.state = STATE::DirCur;
                                        return None;
                                } else {
                                        if valid_fname_char(c) {
                                                if self.buf.len() < 255 {
                                                        self.buf.push(c);
                                                        return None;
                                                } else {
                                                        self.result = Some(Err(PathFormatError::FileNameTooLong));
                                                        return Some(Err(PathFormatError::FileNameTooLong));
                                                }
                                        } else {
                                                self.result = Some(Err(PathFormatError::InvalidCharInFileName));
                                                return Some(Err(PathFormatError::InvalidCharInFileName));
                                        }

                                }
                        },
                        STATE::DirCur => {
                                if c == '/' {
                                        self.state = STATE::FName;
                                        return None;
                                } else if c == '.' {
                                        self.state = STATE::DirParent;
                                        return None;
                                } else if valid_fname_char(c) {
                                        self.buf.push(c);
                                        self.state = STATE::FName;
                                        return None;
                                } else {
                                        self.result = Some(Err(PathFormatError::InvalidCharInFileName));
                                        return Some(Err(PathFormatError::InvalidCharInFileName));
                                }
                        },
                        STATE::DirParent => {
                                if c == '/' {
                                        self.state = STATE::FName;
                                        self.path.path.push(String::from(".."));
                                        self.buf.pop();
                                        return None;
                                } else if valid_fname_char(c) {
                                        self.buf.push(c);
                                        self.state = STATE::FName;
                                        return None;
                                } else {
                                        self.result = Some(Err(PathFormatError::InvalidCharInFileName));
                                        return Some(Err(PathFormatError::InvalidCharInFileName));
                                }
                        }
                }
        }

        /// Get parse result
        fn finish(mut self) -> Result<Path, PathFormatError> {
                if let Some(error) = self.result {
                        return error;
                }
                match self.state {
                        STATE::Start => {
                                return Err(PathFormatError::EmptyPath);
                        },
                        STATE::FName => {
                                if self.buf.len() == 0 {
                                        self.path.must_dir = true;
                                        return Ok(self.path);
                                } else {
                                        self.path.path.push(self.buf);
                                        return Ok(self.path);
                                }
                        },
                        STATE::DirCur => {
                                self.path.must_dir = true;
                                return Ok(self.path);
                        },
                        STATE::DirParent => {
                                self.path.path.push(String::from(".."));
                                self.path.must_dir = true;
                                return Ok(self.path);
                        }
                }
        }
}

/// Using parser to parse path
pub fn parse_path(path: &str) -> Result<Path, PathFormatError> {
        // debug!("parse_path: path {}", path);
        let mut parser = PathParser::new();
        let chars = path.chars();
        for c in chars {
                if c == 0 as char {
                        break;
                }
                if let Some(error) = parser.read(c) {
                        return error;
                }
        }
        return parser.finish();
}


